This is an exercise to translate real-world objects into object oriented principles. 
Nathan noticed that in our environment there is an Odwalla cooler. 
He's noticed that it is capable of being turned on, turned off.
It can also have its door open, and door closed.
We've also noticed that the cooler has a capacity, which is defined as the total 
number of slots it has for bottles.


Feature: We can turn the cooler on
Scenario:
As a business owner who wants to keep my things cold, I require a cooler.
Sometimes I would like to turn the cooler on, other times I would like to turn it off.

To-Do List 
<a href="/features/DONE.md">Done List</a>
/ BDD Record
<table>
	<thead>
		<tr>
		  <th>Feature</th>
		  <th>Story</th>
		  <th>Status</th>
		</tr>
	</thead>
	<tbody>
		<tr>
		  <td>Set the Cooler's Custom Upper Capacity (Desired Maximum Stock)</td>
		  <td>
		    <ul>
		       <li> Given: I have a cooler</li>
		       <li> And: I don't want to use it's full physical capacity for stock</li>
		       <li> When: I define a custom capacity for the cooler</li>
		       <li> Then: I should be able to confirm the capacity is set correctly</li>
		       <li> Example: I have a cooler with a maximum physical capacity of 100 bottles. However, I want to keep my stock level at or below 50. After I set the custom capacity to 50, when I ask the cooler how many bottles it is able to hold, rather than returning what it can physically hold, 100, it should tell me it can only hold 50. </li>
		  </td>
		  <td>Implemented, needs refactoring in the method name to distinguish it from the upcoming minimum capacity threshold, and to more accurately reflect what it does (Setting Maximum Desired Stock, which is different than capacity)</td>
		</tr>
		
		<tr>
		  <td>Create a Cooler with Logical Predefined Characteristics</td>
		  <td>
		    <ul>
		       <li> Given: I am a business owner, and I want to have a cooler</li>
		       <li> When: I acquire the cooler</li>
		       <li> Then: That cooler should come with certain predefined characteristics, specifically physical capacity, and the power state should be off initially, as well as the door closed. (Just like the state it would be in immediately after delivery from a potential cooler manufacturer)</li>
		  </td>
		  <td>Not Yet Implemented</td>
		</tr>
		
		<tr>
		  <td>Create a new Order from Cooler</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: I want to add more stock</li>
		       <li> Then: I should be able to create an order containing the desired bottles I want for my cooler </li>
		  </td>
		  <td>Implemented, needs refactoring. Currently the cooler creates and places orders at the same time, that method "order" needs to be split so that it only does one thing. An order can already be added to, we just need to have Cooler use that ability to create orders (potentially multi-beverage) before actually placing them. As it stands now, the cooler can only create/place orders for a single beverage type at a time.</td>
		</tr>
		<tr>
		  <td>Add items to an Order from the Cooler</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: I want to add more stock</li>
		       <li> And: I create an order for that stock </li>
		       <li> Then: I should be able to add multiple containers containing different beverages in each to the order</li>
		  </td>
		  <td>Not Yet Implemented - but Order already has this ability. Implementing this will simply be calling that method from order, resulting in duplication. I'll get the method working first, then look at pushing up to a potential Orderer Class</td>
		</tr>
		<tr>
		  <td>Place Order from Cooler</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: I want to add more stock</li>
		       <li> And: I create an order for that stock </li>
		       <li> Then: I should be able to place that order and have the bottles added to the cooler's stock</li>
		  </td>
		  <td>Implemented, but currently mashed in with the Create Order from Cooler feature as method Cooler.order(). I need to refactor this to a seperate method</td>
		</tr>
		<tr>
		  <td>Veto Over-Capacity Order</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: I place an order for more bottles</li>
		       <li> And: The bottles ordered will put the cooler over capacity</li>
		       <li> Then: The order should be rejected </li>
		       <li> Example: If I have a cooler with 10 Monsters and 15 Rockstars that has a custom capacity defined at 50 bottles, if I try to order more than 25, so say 20 Monsters and 20 Rockstars, then the order will be rejected</li>
		  </td>
		  <td>Implemented, will need refactoring after separating Create Order from Place Order and adding an Add to Order method in Cooler (to allow for creating an order with multiple containers, and thus beverage types, before submitting the order) because the check will need to run at the Place Order step at that point</td>
		</tr>
		<tr>
		  <td>Orders Composed of More Than 1 Beverage</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: I want to place an order for more than 1 beverage</li>
		       <li> Then: The order should be able to be composed of multiple containers, each containing a desired beverage</li>
		       <li> Example: If I have a cooler with 10 Monsters and 15 Rockstars and I want to double my stock, I should be able to compose an order containing both those items, rather than having two orders</li>
		  </td>
		  <td>DONE</td>
		</tr>
		<tr>
		  <td>Cooler has the ability to edit orders before they are sent</td>
		  <td>
		    <ul>
		       <li> Given: A cooler in need of some stock</li>
		       <li> When: I create an order for additional stock</li>
		       <li> And: I add to the order</li>
		       <li> Then: The additions should be a part of the order</li>
		  </td>
		  <td>Refactor after creating Orderer</td>
		</tr>
		<tr>
		  <td>Orderer has the ability to create orders</td>
		  <td>
		    <ul>
		       <li> Given: A cooler in need of some stock</li>
		       <li> When: I want to create an order for additional stock</li>
		       <li> Then: The responsibility of creating that order should be with the Orderer, Cooler just needs to let it know what it needs</li>
		  </td>
		  <td>Not Yet Implemented</td>
		</tr>
		<tr>
		  <td>Automatic Reorder!</td>
		  <td>
		    <ul>
		       <li> Given: A cooler with some stock</li>
		       <li> When: A bottle or bottles are removed</li>
		       <li> And: The stock % full reaches a lower limit threshold
		       <li> Then: The cooler should automatically place a new order to the BottleManufacturer, composed of the items in the removed stock list (meaning it doesn't have to compose the order at this point, just pass the list, so this method only does one thing!), ensuring it's stock levels will be restored to their original state</li>
		  </td>
		  <td>Needs Refactoring after Orderer</td>
		</tr>
	</tbody>
	<tfoot>
	</tfoot>
</table>
------------------------
Coming up in the future: (Ideas for features and refactoring not fully fleshed out yet or just otherwise not added to the above feature list)


- SUPER EPIC WIN Feature: The cooler vetoes the door being open more than 10 degrees
- Abstract the Manufacturer class...then the order process could be valid for more than just bottles
- Explore the concept of backstock, and how that might affect the ordering/stocking process
- Refactor the tests with more consistent stock levels so you can avoid the duplication of having to add bottles to the cooler every time before a test, if at all possibl
- Factor out the Beverage from the Bottle.
- We should probably be able to use the cooler as something besides a Pez dispenser :D